<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="shortcut icon" href="img/a.gif" type="image/gif">
<title>Артём Степанов - Junior Front-End Developer</title>
	<meta name="description" content="Front-End Developer в Киеве ▶ Разработчик сайтов ▶ Знание JS, HTML5, CSS3 ▶ Знание английского на уровне чтения и понимания технической документации">
        <link rel="stylesheet" href="css/style.css">
	</head>
    <body>
        <header class="header">
            <img class="bg" alt="">
            <img class="logo" src="img/Tema 2.png" alt="logo">
		<img class="logo480px" src="img/9.png" alt="logo480px">
        <nav class="nav">
            <ul class = "menu">
                <li><a class = "a" href="about me.html">Обо мне</a></li>
                <li><a class = "b" href="skills.html">Навыки</a></li>
                <li><a class = "c" href="certificates.html">Сертификаты</a></li>
    
            </ul>
        </nav>
        <canvas id="c"></canvas>
        <h1 class = "name">Artem Stepanov </h2>
    <h2 class="name-info">Junior Front-End developer</p>

       
        <script type="module">
    
    import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';
import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/loaders/GLTFLoader.js';
import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

 function main() {
    const canvas = document.querySelector('#c');

    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha: true,
    });
  const fov = 75;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 5;
  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  camera.position.z = 2;
      // Controls
	function onDocumentMouseMove( event ) {

    event.preventDefault();

    if ( isMouseDown ) {

        theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 )
                + onMouseDownTheta;
        phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 )
              + onMouseDownPhi;

        phi = Math.min( 180, Math.max( 0, phi ) );

        camera.position.x = radious * Math.sin( theta * Math.PI / 360 )
                            * Math.cos( phi * Math.PI / 360 );
        camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
        camera.position.z = radious * Math.cos( theta * Math.PI / 360 )
                            * Math.cos( phi * Math.PI / 360 );
        camera.updateMatrix();

    }

    mouse3D = projector.unprojectVector(
        new THREE.Vector3(
            ( event.clientX / renderer.domElement.width ) * 2 - 1,
            - ( event.clientY / renderer.domElement.height ) * 2 + 1,
            0.5
        ),
        camera
    );
    ray.direction = mouse3D.subSelf( camera.position ).normalize();

    interact();
    render();

}
    
    // Controls
    scene = new THREE.Scene();
  const boxWidth = 1;
  const boxHeight = 1;
  const boxDepth = 1;
  const geometry = new THREE.BoxBufferGeometry(boxWidth, boxHeight, boxDepth);

  const cubes = [];  // just an array we can use to rotate the cubes
  const loader = new THREE.TextureLoader();

  const materials = [
    new THREE.MeshBasicMaterial({map: loader.load('img/1.jpg')}),
    new THREE.MeshBasicMaterial({map: loader.load('img/2.jpg')}),
    new THREE.MeshBasicMaterial({map: loader.load('img/3.JPG')}),
    new THREE.MeshBasicMaterial({map: loader.load('img/4.jpg')}),
    new THREE.MeshBasicMaterial({map: loader.load('img/5.JPG')}),
    new THREE.MeshBasicMaterial({map: loader.load('img/6.jpg')}),
  ];
  const cube = new THREE.Mesh(geometry, materials);
  scene.add(cube);
  cubes.push(cube);  // add to our list of cubes to rotate

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render(time) {
    time *= 0.001;

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    cubes.forEach((cube, ndx) => {
      const speed = .1 + ndx * .1;
      const rot = time * speed;
      cube.rotation.x = rot;
      cube.rotation.y = rot;
      cube.rotation.z = rot;
    });

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
        </script>
	      </header>

	</body>
</html>
